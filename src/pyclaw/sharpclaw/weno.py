"""Generate Fortran WENO kernels with PyWENO."""

# Copyright (c) 2011, Matthew Emmett.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#   1. Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#   2. Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials provided
#      with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import pyweno.symbolic
import pyweno.kernels
import pyweno.functions
import pyweno.templates
import os.path
import pickle

import numpy as np

codegen = pyweno.functions.FunctionGenerator('fortran')

K = range(3, 6)

if os.path.exists('cache.pkl'):
  with open('cache.pkl', 'r') as f:
    cache = pickle.load(f)
    cached = True
else:
  cache = {}
  cached = False

#### open weno.f90 and write header

out = open('weno.f90', 'w')
out.write('! This file was generated by: python weno.py\n')
out.write('module weno\ncontains')


#### generate and write uniform reconstruction functions

pyweno.templates.templates['fortran']['callable'] = '''
subroutine {function}(q, ql, qr, num_eqn, maxnx, num_ghost)

  implicit none

  integer,          intent(in)  :: num_eqn, maxnx, num_ghost
  double precision, intent(in)  :: q(num_eqn,maxnx+2*num_ghost)
  double precision, intent(out) :: ql(num_eqn,maxnx+2*num_ghost), qr(num_eqn,maxnx+2*num_ghost)

  integer :: i, m
  double precision :: {variables}

  do i = num_ghost-1, maxnx+num_ghost+1
    do m = 1, num_eqn
      {kernel}
    end do
  end do

end subroutine
'''
pyweno.kernels.global_names['fortran'] = 'q(m,i{r:+d})'

for k in K:

  print 'generating reconstruction for k: %02d' % k

  # compute beta, varpi, coeffs
  if not cached:
    beta = pyweno.symbolic.jiang_shu_smoothness_coefficients(k)
    (varpi, split) = pyweno.symbolic.optimal_weights(k, [ -1, 1 ])
    coeffs = pyweno.symbolic.reconstruction_coefficients(k, [ -1, 1 ])
    cache[(k,'beta')] = beta
    cache[(k,'varpi')] = varpi
    cache[(k,'split')] = split
    cache[(k,'coeffs')] = coeffs
  else:
    beta   = cache[(k,'beta')]
    varpi  = cache[(k,'varpi')]
    split  = cache[(k,'split')]
    coeffs = cache[(k,'coeffs')]

  codegen.set_smoothness(beta)
  codegen.set_optimal_weights(varpi, split)
  codegen.set_reconstruction_coefficients(coeffs)

  # tweak reconstructed function (f_star) names to match subroutine
  # definition above
  codegen.global_f_star[0] = 'ql(m,i)'
  codegen.global_f_star[1] = 'qr(m,i)'

  # write function
  out.write(codegen.generate(
      smoothness=True, weights=True, reconstruct=True, normalise=False,
      function='weno%d' % (2*k-1)))

if not cached:
  with open('cache.pkl', 'w') as f:
    pickle.dump(cache, f)


#### generate and write uniform reconstruction functions

pyweno.templates.templates['fortran']['callable'] = '''
subroutine {function}(q, ql, qr, num_eqn, maxnx, num_ghost, beta, varpi, coeffs)

  implicit none

  integer,          intent(in)  :: num_eqn, maxnx, num_ghost
  double precision, intent(in)  :: q(num_eqn,maxnx+2*num_ghost)
  double precision, intent(out) :: ql(num_eqn,maxnx+2*num_ghost), qr(num_eqn,maxnx+2*num_ghost)
  double precision, intent(in)  :: &
                beta(maxnx+2*num_ghost,0:{k}-1,0:{k}-1,0:{k}-1), &
                varpi(maxnx+2*num_ghost,0:1,0:{k}-1), &
                coeffs(maxnx+2*num_ghost,0:1,0:{k}-1,0:{k}-1)

  integer :: i, m
  double precision :: {variables}

  do i = num_ghost-1, maxnx+num_ghost+1
    do m = 1, num_eqn
      {kernel}
    end do
  end do

end subroutine
'''
pyweno.kernels.global_names['fortran'] = 'q(m,i{r:+d})'

for k in K:

  print 'generating nonuniform reconstruction for k: %02d' % k

  # set smoothness
  codegen.set_nonuniform(k, 2)

  # tweak reconstructed function (f_star) names to match subroutine
  # definition above
  codegen.global_f_star[0] = 'ql(m,i)'
  codegen.global_f_star[1] = 'qr(m,i)'

  # write function
  out.write(codegen.generate(
      smoothness=True, weights=True, reconstruct=True, normalise=False,
      function='weno%d_mapped' % (2*k-1)))


#### done

out.write('end module weno')
out.close()
